---
title: A program for literate Prolog
author: Richard de Rozario
date: 17 July 2019

---

# Introduction
The SWI Prolog environment enables literate programming in the form of program comments. However, there is another form of literate programming that embeds the program code as specially marked chunks in a text document.  A prominent example of this is supported in the R language environment -- especially in RStudio, in the form of .Rmd files.  These files are documents that are written in the markdown format, with the program embedded in specially marked chunks throughout the text.  The document is processed by a program that formats the text and code into a final output like a pdf file. The <code>lit.pro</code> program discussed here supports all these functions for the Prolog language (in particular SWI Prolog).

An additional benefit is that code chunks like examples can be executed during the processing and the results shown in the document.  In essence, this supports "programmatic" documents, where part of the text (including diagrams, tables, etc.) is generated by code.  This is useful for documents like tutorials or reports. These types of documents are the primary motivation for writing this program.

Lastly, the program can also extract the code into a "sourcecode only" file that can be executed by the language interpreter or compiler. The extraction process is flexible through the use of "tags" in the code chunks, which enable extraction of chunks that have particular tags, like "example" or "main_code".

This document is itself the literate program (<code>lit.pro</code>) that performs these functions. In other words, the text documents the source code, which is presented in chunks throughout the document. In essence, this document is the reference guide to the program.^[In order to avoid predicate naming clashes, all the predicates in the actual lit.pro source code have been renamed with an <code>_4lit</code> suffix.  This enables <code>lit</code> to process documents without accidentally running into predicate name clashes from embedded code chunks.  In this document, the suffixes are not present for readability.]

# A brief usage example
To demonstrate the main features, I'll write a small program and show how to process it with  <code>lit.pro</code>.  First, a small "hello world" program, written in a literate Prolog document.  The text shown in Listing \ref{ex1} would be saved in a file called, for example, <code>hello.pmd</code>, which is basically a markdown text file, with chunks of prolog code amongst the text.

%% ex1 "hello world literate Prolog example"

%%

~~~
    ---
    title: Example prolog markdown
    author: RdR
    date: 2019-07-07

    ---

    # Introduction
    This is example Prolog markdown text that is 
    processed by the lit.pro program.  The main text
    is formatted in markdown and the code is demarcated
    by double-percent signs.


    %% mycode "hello world"

    main :- hello( world ).
    hello(X):- write('**'),write('hello '), write(X), writeln('**').

    :- main.

    %%

    The code shown in Listing \ref{mycode} is a 
    simple Prolog program.  The code is executed when this
    document is processed by the lit.pro program.

~~~

If the text in Listing \ref{ex1} exists in a file called "hello.pmd", then on the commandline the following would process the file and produce a nicely formatted pdf document.^[Assuming that you have pandoc installed.]

~~~
./lit hello.pmd
~~~

The text in the pdf will appear formatted much like the document you're reading now.  The code block would appear as follows:

%% mycode "hello world"

main :- hello( world ).
hello(X):- write('**'),write('hello '), write(X), writeln('**').

:- main.

%%



Notice that the output of the program ("hello world") appears just after the code block. That is, the output of the program (if there is any) is injected into the text of the document.  By default, <code>lit.pro</code> will provide line numbers in the margins for code listings.  To turn that off, you can include the tag "nonum" like the following:

~~~
    %% mycode "hello world" nonum

~~~

The syntax of the line that marks the start of a code block is very simple:

~~~
    %% LABEL [CAPTION] [TAG]*

~~~

In other words, the double-percent marker followed by a label of the code chunk and optionally a caption for the listing and zero or more tags.  Using the pandoc format of markdown, the label of the code chunk can also be used for references to the listing, for instance the use of  \\ref{mycode} in Listing \ref{ex1}.

Tags can be any alphanumeric (including underscores) word, starting with a letter.  The following are reserved tags:

* nonum  &mdash; list code without line numbers
* nolist &mdash; don't list the code (but still evaluate it)
* noeval &mdash; list the code, but don't evaluate it
* skip &mdash; do not list or evaluate the code

Other than the reserved tags, you're free to use any word to tag your code. Aside from searching for relevant code, tags also enable you to process or extract only certain chunks. For example, let's say that you have both the main program code, as well as example code in your document.   You might use tags "main" and "example" to distinguish between them.  Then, you could extract all the main code from the document into a separate <code>.pro</code> file from the commandline as follows:

~~~
    ./lit -x -t main myprogram.pmd
~~~


# The annotated source code of lit.pro

The following sections will discuss the source code of the <code>lit.pro</code> program.

## The "main" section

There are two global declarations:

* the <code>gensym</code> library is loaded, because we need to generate temporary unique filenames when processing chunks of code.  The chunks are stored into a temporary file and then consulted into the Prolog environment.
* <code>b/2</code> is a dynamic predicate used for temporarily storing lines of code (via Prolog's <code>assertz</code>), before writing them out to a file.

The main predicate provides the top-level program starting point.  It sets up the error handling and then calls <code>args(Args), submain(Args)</code>, which grabs the commandline arguments and further processes them in <code>submain</code>.

Submain handles three things: process the syntax of the commandline arguments, call the core routine for processing the text in the document (<code>lit/5</code>), or print the help message if processing cannot occur for some reason.

%% main_section "program main section" noeval
% lit.pro 
%   Enable literate Prolog programs, where the file is a markdown text,
%   interspersed with chunks of code.  Small snippets of code can also
%   be embedded in the text inside backquotes.  The program will interpret
%   the code, insert any output and display code as directed.
% 
%   To compile: swipl -o lit -g main -c lit.pro
%

:- ensure_loaded(library(gensym)).
:- dynamic(b/2).

main:-
    catch( (args(Args), submain(Args)), Err, (writeln(Err),fail)),
    halt.
main:- halt(1).

args(Args):-  
    current_prolog_flag(os_argv,[_,_,_,_|Args]),!.
args([]):-!.

%! submain(-Args:list) is det.
%   Submain extracts the arguments from the command line 
%   and calls the core program
submain(Args):-
    ( argline(Infile,Outfile,CodeOnly,Tags,Postproc,Args,_) ->
        lit(Infile,Outfile,CodeOnly,Tags,Postproc)
    ;   print_arghelp   % no args at all
    ),!.

%%

## The commandline arguments
The commandline arguments appear as a list of atoms, which are handled with a DCG grammar. The intent of the grammar is to extract the variables <code>Infile</code>, <code>Outfile</code>, <code>CodeOnly</code>, <code>Tags</code> and <code>Postproc</code>, which are explained below. The grammar essentially handles each of the dash-options (which may occur in any order):

* -h or --help &mdash; these simply print out the help message, although they are superfluous because just executing the program without any arguments will also print the help text.
* -x &mdash; this option will extract the code into a separate sourcecode file with the same name, but with an extension of <code>.pro</code> (unless a specific output filename is provided).  This option also interacts with tags (if they are provided) and will only extract code that contains one or more of the tags specified.  Programmatically, the grammar handles the option by setting the <code>CodeOnly</code> parameter to <code>true</code>.
* -p &mdash; this option enables the user to set their own post-processing command.  The <code>lit</code> program only transforms a <code>.pmd</code> program (markdown text + Prolog code) into a regular <code>.md</code> file.  That <code>.md</code> file can then be further processed into, say, a <code>.pdf</code> file.  By default, we use pandoc for this post-processing, but the user may wish to use some other program.  Programmatically, the post-processing command is a string on the commandline that is stored as an atom in the Postproc variable of the grammar.
* -t &mdash; this option enables the user to provide a (comma separated) list of tags. Some tags are reserved words (like "nonum" which lists code without line numbers), but most are used to select which code chunks should be processed.  Any code chunk that has one or more of the tags specified on the commandline will be processed.
* -o &mdash; this option specifies an outputfile. If the option is not specified, the program will use the input file name, but with the <code>.md</code> extension for the output file name (unless the <code>-x</code> option is used, in which case the <code>.pro</code> extension is used by default).
* inputfilename &mdash;  the input file name is required for any processing to occur.  The naming convention for the input file name is a file with the <code>.pmd</code> extension.  To prevent accidental overwriting of files, we don't allow input files with either a <code>.md</code> or a <code>.pro</code> extension.

The grammar is straigthforward. One minor special case is the handling of comma-separated tags.  Since by convention most people don't put a space before a comma, the comma ends up attached to the atom that is the tag.  We separate the two with the <code>commaed</code> predicate.

%% argline "the argument line grammar" noeval
%! argline(?Infile,?Outfile,?CodeOnly,Tags:list,Toks:list,Rest:list) is semidet.
%   The command line argument grammar.
argline(_,_,_,_,_) --> ['-h'], {print_arghelp}, !.
argline(_,_,_,_,_) --> ['--help'], {print_arghelp}, !.
argline(Infile,Outfile,true,Tags,Postproc) -->    % extract code only
    ['-x'],
    !, arglinetail(Infile, Outfile, true, Tags,Postproc).
argline(Infile,Outfile,CodeOnly,Tags,Postproc) -->
    ['-p',Postproc],
    !, arglinetail(Infile, Outfile,CodeOnly,Tags,Postproc).

% process code with any of these tags only
argline(Infile,Outfile,CodeOnly,Tags,Postproc) -->       
    ['-t'],[T], 
    {   T\='-x',T\='-o',T\='-h',T\='--help',
        file_name_extension(T,'',T),
        (commaed(T,Tag) -> Tag=Tag; Tag=T )
    },
    more_tags(Ts), {append([Tag],Ts,Tags)},
    !, arglinetail(Infile, Outfile, CodeOnly, Tags,Postproc).

argline(Infile,Outfile,CodeOnly,Tags,Postproc) -->
    ['-o',Outfile],
    {    not(access_file(Outfile,write)) -> 
            throw('Error: cannot access output file');! 
    },!, arglinetail(Infile, Outfile,CodeOnly,Tags,Postproc).

argline(Infile,Outfile,CodeOnly,Tags,Postproc) -->
    [Infile],
    {    not(access_file(Infile,read)) -> 
            throw('Error: cannot access input file');! 
    },!, arglinetail(Infile, Outfile,CodeOnly,Tags,Postproc).

arglinetail(_,_,_,_,_,[],[]):-!.
arglinetail(In,Out,Code,Tags,Post,S,F):- 
    argline(In,Out,Code,Tags,Post,S,F).

more_tags(Tags) --> [','], more_tags(Tags),!.
more_tags([Tag|Tags]) --> 
    [T], 
    {   T\='-x',T\='-o',T\='-p',T\='-h',T\='--help',
        file_name_extension(T,'',T),
        (commaed(T,Tag) -> Tag=Tag; Tag=T )
    },!, 
    more_tags(Tags).
more_tags([]) --> {}.

commaed(Word,Atom):-
    atom_chars(Word,Cs),
    append(As,[','],Cs),
    atom_chars(Atom,As),!.

%! print_arghelp is det.
%   display the command line help
print_arghelp:-
    nl,
    writeln('Literate Prolog programs using markdown files.'),
    writeln('usage: lit [-x ] [-p "post processing command"] [-t tag1[, tag2, ..., tagn] ] [-o outputfile] inputfile'),
    writeln('-x  will extract code only into outputfile'),
    writeln('-p "..." is the postprocessing command. default="pandoc --listing -o %w.pdf %w.md", where %w is extensionless filename'),
    writeln('-t tag1[, tag2, ..., tagn]  will only process code blocks with any of these tags'),
    writeln('-o  specify outputfile name. Default is inputfile, but with .md extension, or .pro in case of -x option.'),
    !.

%%


## The core process of "lit" 

The <code>lit</code> predicate is the start of the core processing of lines from the input document. Lit is called after the commandline arguments have been processed, so we first have to ensure that all the parameters have appropriate values.  For example, it may be that the user did not specify an output file name, which means we have to set <code>Outfile</code> to some default value.  The <code>lit</code> predicate handles all the initiation of these key variables.

After that, we iteratively read a line from the input file and hand that line off to the line grammar.  The <code>process_lines</code> predicate handles this.

The remainder of the core program are the grammar for each document line, and the evaluation rules to accompany the grammar.  

### Ensure that all parameters are set

%% lit "the core program 'lit'" noeval
%! lit(+Infile:atom, ?Outfile:atom, ?CodeOnly:atom) is det.
%   process the commandline arguments (like opening file handles) and pass to
%   the core program.
lit(Infile, Outfile, CodeOnly, Partags,Postproc):-
    ( ground(CodeOnly) -> true; CodeOnly = false),
    ( \+ground(Partags) -> Partags=[]; true),
    ( \+ground(Postproc) -> 
        (   member(nonum,Partags) -> 
                Postproc='pandoc -o %w.pdf %w.md'; 
                Postproc='pandoc --listing -o %w.pdf %w.md'
        ); true
    ),
    ( \+ground(Outfile) -> 
        (   file_name_extension(N,E,Infile),
            ( (E=='pro';E=='md') -> 
                throw('Error: input file cannot be .pro or .md to avoid accidental overwriting of source.');
                true
            ),
            (CodeOnly -> Ext='pro'; Ext='md'),
            file_name_extension(N,Ext,Outfile)
        ); true
    ),
    open(Outfile,write, Out,[]),

    (ground(Infile) -> 
        (   open(Infile, read, In,[]),
            current_output(Serr),       % user current output for errors and warnings
            with_output_to(Out,process_lines(Serr,In,CodeOnly,Partags,text,1)),
            close(Out),
            close(In),
        
            % post processing
            ( \+CodeOnly -> 
                (   file_name_extension(Base,_,Outfile),
                    swritef(Cmd,Postproc,[Base,Base]),
                    shell(Cmd,[])
                ); true
            )
        );   
        print_arghelp
    ),!.

%%

### Iteratively process lines


%% loop "iteratively process lines" noeval
%! process_lines(+In:handle,+CodeOnly:atom,+Partags:list,+Lnum:integer) is det.
%   Process: read line and process according to type of line and state of processing
process_lines(Serr,In,CodeOnly,Partags,State,Lnum):-
    (\+ at_end_of_stream(In)),
    read_line_to_codes(In, Codes),
    aline(Serr,CodeOnly,Partags,Lnum,Codes,State,Newstate),!,
    Lnext is Lnum + 1,
    process_lines(Serr,In,CodeOnly,Partags,Newstate,Lnext).
process_lines(_Serr,_In,_CodeOnly,_Partags,_State,_Lnum).

%%


### The grammar of document lines
Individual lines in the document are essentially of two types: a codeblock start (or end), or a text line.  However, the codeblock start can imply a number of different "processing states".  Namely, we may wish to list or evaluate the code (or a combination of the two), depending on the tags given in the codeblock header or the commandline parameters.

So, the grammar also keeps track of the processing state according to the following state transition rules:

* we start in the "text" state
* any state can transition into the "code" state via the codeblock opening line, unless the tags in the codeblock line indicate another state (e.g. a "skip" state)
* any state can transition into the "skip" state via the codeblock opening line, if that line contains the "skip" tag
* any state can transition into the "noeval" state via the codeblock opening line, if that line contains the "noeval" tag
* any state can transition into the "nolist" state via the codeblock opening line, if that line contains the "nolist" tag
* any state can transition into the "text" state via the codeblock closing line (a line with just the two-percent signs)
* any state persists if the input line is not a codeblock line

Note that text lines are also evaluated according to a detailed grammar (see <coce>eval_textline</code) that looks for inline code.  Also, in the "code" and "nolist" states (i.e. any state where code is supposed to be evaluated), the code lines are stored in the Prolog database with the <code>b/2</code> predicate.  Then, when the code block finishes, the lines are written out to a temporary file, and consulted back into the Prolog environment (i.e. evaluated).  This is done at the end of the codeblock, using the call to <code>eval_codeblock</code>.

%% lines "grammar of a document line" noeval
%! aline(+CodeOnly:atom,+Lnum:integer,+Chars:list,+State:atom,-Newstate:atom) is semidet.

% codeblock start
aline(Serr,CodeOnly,Partags,_Lnum,Codes,_,Outstate):-        
    codeblock_start(CodeOnly,Partags,Outstate,Codes,Rest),
    (   (length(Rest,L), L>0) ->
            (   write(Serr,'Line '), 
                write(Serr,'. Unknown syntax ignored: '),
                string_codes(S,Rest),
                write(Serr,S)
            ); true
    ). 

% text line
aline(_Serr,false,_Partags,_Lnum,Codes,text,text):-         
    \+codeblock_intro(Codes,_),
    eval_textline(Cs,Codes,_),
    writef('%s\n',[Cs]).

% skipped code line
aline(_Serr,_CodeOnly,_Partags,_Lnum,Codes,skip,skip):-     
    \+codeblock_intro(Codes,_).

% not listed codeline
aline(_Serr,_CodeOnly,_Partags,Lnum,Codes,nolist,nolist):-  
    \+codeblock_intro(Codes,_),
    append_codeline(Lnum,Codes).

% listed & evaluated codeline
aline(_Serr,_CodeOnly,_Partags,Lnum,Codes,code,code):-      
    \+codeblock_intro(Codes,_),
    writef('%s\n',[Codes]),
    append_codeline(Lnum,Codes).

% not evaluated codeline
aline(_Serr,_CodeOnly,_Partags,_Lnum,Codes,noeval,noeval):- 
    \+codeblock_intro(Codes,_),
    writef('%s\n',[Codes]).

% end of codeblock -- evaluate if needed
aline(_Serr,CodeOnly,_Partags,_Lnum,Codes,Instate,text):-   
    codeblock_intro(Codes,[]),
    ( (\+CodeOnly, Instate\=skip, Instate\=nolist) -> writef('\n~~~\n\n'); true),
    ( (Instate\=skip, Instate\=noeval) -> eval_codeblock; true).

aline(_Serr,_CodeOnly,_Partags,_Lnum,_Codes,State,State).

%%

### The grammar for start and end of codeblocks

The line that opens a codeblock has a simple grammar of double-percent signs, a label and optional caption and tags. That grammar is translated into Pandoc's grammar for codeblocks (which uses, for example, triple tildes instead of double percent).

%% codeblock "grammar for start and end of a codeblock" noeval
% grammar for line that starts a codeblock
% Grammar: %% mylabel ["mycaption"] [ tag1[, tag2[, tag3...]]]
% Reserved tags: nolist noeval skip nonum
codeblock_start(CodeOnly,Partags,Outstate) --> 
    codeblock_intro,
    label(Label),
    whitespace,
    caption(Caption),
    whitespace, 
    tags(Tags),
    {   codeblock_state(Partags,Label,Tags,Outstate), 
        ( (\+CodeOnly, Outstate \= skip, Outstate \= nolist) ->
            (   writef('~~~{ .prolog label=%w caption="%w" numbers=',[Label,Caption]),
                ( (\+member(nonum,Tags),\+member(nonum,Partags)) -> write('left ');write('none ')),
                maplist(write_dottag,Tags),
                writeln('}')
            );
            true
        )   
    },!.

% codeblock line start or end
codeblock_intro --> [37,37], whitespace.        % 37='%'

% Note codeblock_state are listed in order for efficiency.
codeblock_state(Partags,Label,Tags,skip):-
    (member(skip,Tags);nopartags(Partags,[Label|Tags])),!.
codeblock_state(_,_,Tags,nolist):-
    member(nolist,Tags),!.
codeblock_state(Partags,_,Tags,noeval):-
    (member(noeval,Tags);member(noeval,Partags)),!.
codeblock_state(_,_,_,code):-!.

write_dottag(A):- write('.'), write(A), write(' ').

%%

### Detailed grammar for labels, captions and tags

A line of text from the document presents itself as a list of character codes.  The detailed grammar below chunks those character lists into grammar elements like labels, captions and tags.

%% details "grammar details" noeval
% whitespace is spaces or tabs.  End-of-line is handled separately
whitespace --> [C], {C=9;C=32}, whitespace.     % 9=tab, 32=space
whitespace --> {}.

% label is a sequence of a letter, followed by alphanumerics or underscores
label(Label) --> [A], {letter(A)}, label_tail(As), {atom_chars(Label,[A|As])},!.
label_tail([A|As]) --> [A], {alpha_num(A)}, label_tail(As).
label_tail([]) --> {}.

lowercase(C):- C > 96, C < 123.     %  'a' <= C <= 'z'
uppercase(C):- C > 64, C < 91.      %  'A' <= C <= 'Z'
letter(C) :- (lowercase(C); uppercase(C)),!.
digit(C):-  C > 47, C < 58.         %  '0' <= C <= '9'
alphanum(C):- (digit(C); letter(C)),!.
alpha_num(C):- (C=95; alphanum(C)),!.   % '_'=95

% caption is any text inside double quotes
caption(Caption) --> [34], caption_text(Cap), [34], {atom_chars(Caption,Cap)},!.  % 34='"'
caption('-') --> {}.
caption_text([A|As]) --> [A], {A\=34}, caption_text(As).
caption_text([]) --> {}.

% tags is a sequence of multiple labels, perhaps separated by commas, semicolons, tabs or spaces
tags([T|Tags]) --> label(T), separator, tags(Tags).
tags([]) --> {}.

% separator
separator --> [C], {C=32;C=9;C=59;C=44}, separator.  % 32=space, 9=tab, 59=semicolon, 44=comma
separator --> {},!.

% nopartags succeeds if partags is not empty, but no partag is in Tags
nopartags([P],Tags):- \+member(P,[nolist,noeval,nonum]),\+member(P,Tags).
nopartags([P|Ps],Tags):- 
    (member(P,[nolist,noeval,nonum]) -> true; \+member(P,Tags)), 
    nopartags(Ps,Tags).

%%


### Actions on various parts of the line grammar

There are two main actions that require supporting predicates:  evaluating inline code snippets and evaluating multi-line code chunks.  The former are evaluated with <code>call(...)</code> and the latter by writing the code to a temporary file and then consulting the file back in.

%% inline "evaluation an inline clause" noeval
% evaluate an inline clause
% e.g. "The X value is `foo(X), write(X)`" will transform into "The X value is 42"
%      on the assumption that foo(X) evaluates to foo(42).
eval_textline([C|Cs]) --> [C], {C\=96}, !, eval_textline(Cs).
eval_textline(Cs) --> 
    [C], {C=96},                % 96 = '`' (backtick)
    eval_codechunk(CC),
    {   string_codes(S,CC),
        term_string(T,S),
        with_output_to_codes(call(T),Result)
    },
    eval_textline(Ctail),!,
    {append(Result,Ctail,Cs)}.
eval_textline([]) --> {}.

eval_codechunk([C|Cs]) --> [C], {C\=96}, eval_codechunk(Cs).
eval_codechunk([]) -->  [C], {C=96}.

%%


%% eval_block "storing and evaluating a code block" noeval
% append line from codeblock to temporary storage
append_codeline(Lnum,Codes):-
    string_codes(S,Codes),
    assertz(b(Lnum,S)).

% evaluate current block of code in temp storage
eval_codeblock:-
    findall(S,b(_,S),Lines),
    gensym(tmp,ID),
    file_name_extension(ID,pro,Tempfile),
    open(Tempfile,write,F,[]),
    writelnf(F,Lines),
    close(F),
    consult(Tempfile),
    delete_file(Tempfile),
    retractbeyond(0).

% write a list of lines to a file with handle F
writelnf(_,[]):-!.
writelnf(F,[L|Ls]):-
    writeln(F,L),!,
    writelnf(F,Ls).

%%


### Utilities

%% utility "retracting lines from temporary storage" noeval
%! retractbeyond(+H:integer) is semidet
%   remove all b/2 database entries beyond sequence number H.
retractbeyond(H):-
    b(K,_),
    K > H, 
    retract(b(K,_) ),
    fail.
retractbeyond(_).

%%
